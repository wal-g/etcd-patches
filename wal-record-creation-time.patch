diff --git a/server/wal/repair_test.go b/server/wal/repair_test.go
index e2e3294ac..672880b80 100644
--- a/server/wal/repair_test.go
+++ b/server/wal/repair_test.go
@@ -155,7 +155,7 @@ func TestRepairWriteTearLast(t *testing.T) {
 		}
 		return f.Truncate(offset)
 	}
-	testRepair(t, makeEnts(50), corruptf, 40)
+	testRepair(t, makeEnts(50), corruptf, 29)
 }
 
 // TestRepairWriteTearMiddle repairs the WAL when there is write tearing
diff --git a/server/wal/wal.go b/server/wal/wal.go
index db9007877..ba60a82a9 100644
--- a/server/wal/wal.go
+++ b/server/wal/wal.go
@@ -18,6 +18,7 @@ import (
 	"bytes"
 	"errors"
 	"fmt"
+	"github.com/jonboulle/clockwork"
 	"hash/crc32"
 	"io"
 	"os"
@@ -92,12 +93,14 @@ type WAL struct {
 
 	locks []*fileutil.LockedFile // the locked files the WAL holds (the name is increasing)
 	fp    *filePipeline
+
+	clock clockwork.Clock
 }
 
 // Create creates a WAL ready for appending records. The given metadata is
 // recorded at the head of each WAL file, and can be retrieved with ReadAll
 // after the file is Open.
-func Create(lg *zap.Logger, dirpath string, metadata []byte) (*WAL, error) {
+func Create(lg *zap.Logger, dirpath string, metadata []byte, walClock ...clockwork.Clock) (*WAL, error) {
 	if Exist(dirpath) {
 		return nil, os.ErrExist
 	}
@@ -158,6 +161,12 @@ func Create(lg *zap.Logger, dirpath string, metadata []byte) (*WAL, error) {
 		dir:      dirpath,
 		metadata: metadata,
 	}
+	if walClock != nil {
+		w.clock = walClock[0]
+	} else {
+		w.clock = clockwork.NewRealClock()
+	}
+
 	w.encoder, err = newFileEncoder(f.File, 0)
 	if err != nil {
 		return nil, err
@@ -166,7 +175,7 @@ func Create(lg *zap.Logger, dirpath string, metadata []byte) (*WAL, error) {
 	if err = w.saveCrc(0); err != nil {
 		return nil, err
 	}
-	if err = w.encoder.encode(&walpb.Record{Type: metadataType, Data: metadata}); err != nil {
+	if err = w.encoder.encode(&walpb.Record{Type: metadataType, Data: metadata, CreatedAt: w.clock.Now().Unix()}); err != nil {
 		return nil, err
 	}
 	if err = w.SaveSnapshot(walpb.Snapshot{}); err != nil {
@@ -346,6 +355,7 @@ func openAtIndex(lg *zap.Logger, dirpath string, snap walpb.Snapshot, write bool
 		decoder:   newDecoder(rs...),
 		readClose: closer,
 		locks:     ls,
+		clock:     clockwork.NewRealClock(),
 	}
 
 	if write {
@@ -737,7 +747,7 @@ func (w *WAL) cut() error {
 		return err
 	}
 
-	if err = w.encoder.encode(&walpb.Record{Type: metadataType, Data: w.metadata}); err != nil {
+	if err = w.encoder.encode(&walpb.Record{Type: metadataType, Data: w.metadata, CreatedAt: w.clock.Now().Unix()}); err != nil {
 		return err
 	}
 
@@ -894,7 +904,7 @@ func (w *WAL) Close() error {
 func (w *WAL) saveEntry(e *raftpb.Entry) error {
 	// TODO: add MustMarshalTo to reduce one allocation.
 	b := pbutil.MustMarshal(e)
-	rec := &walpb.Record{Type: entryType, Data: b}
+	rec := &walpb.Record{Type: entryType, Data: b, CreatedAt: w.clock.Now().Unix()}
 	if err := w.encoder.encode(rec); err != nil {
 		return err
 	}
@@ -908,7 +918,7 @@ func (w *WAL) saveState(s *raftpb.HardState) error {
 	}
 	w.state = *s
 	b := pbutil.MustMarshal(s)
-	rec := &walpb.Record{Type: stateType, Data: b}
+	rec := &walpb.Record{Type: stateType, Data: b, CreatedAt: w.clock.Now().Unix()}
 	return w.encoder.encode(rec)
 }
 
@@ -960,7 +970,7 @@ func (w *WAL) SaveSnapshot(e walpb.Snapshot) error {
 	w.mu.Lock()
 	defer w.mu.Unlock()
 
-	rec := &walpb.Record{Type: snapshotType, Data: b}
+	rec := &walpb.Record{Type: snapshotType, Data: b, CreatedAt: w.clock.Now().Unix()}
 	if err := w.encoder.encode(rec); err != nil {
 		return err
 	}
@@ -972,7 +982,7 @@ func (w *WAL) SaveSnapshot(e walpb.Snapshot) error {
 }
 
 func (w *WAL) saveCrc(prevCrc uint32) error {
-	return w.encoder.encode(&walpb.Record{Type: crcType, Crc: prevCrc})
+	return w.encoder.encode(&walpb.Record{Type: crcType, Crc: prevCrc, CreatedAt: w.clock.Now().Unix()})
 }
 
 func (w *WAL) tail() *fileutil.LockedFile {
diff --git a/server/wal/wal_test.go b/server/wal/wal_test.go
index 4483a500e..479ddd834 100644
--- a/server/wal/wal_test.go
+++ b/server/wal/wal_test.go
@@ -17,6 +17,7 @@ package wal
 import (
 	"bytes"
 	"fmt"
+	"github.com/jonboulle/clockwork"
 	"github.com/stretchr/testify/require"
 	"io"
 	"io/ioutil"
@@ -53,7 +54,7 @@ func TestNew(t *testing.T) {
 	}
 	defer os.RemoveAll(p)
 
-	w, err := Create(zap.NewExample(), p, []byte("somedata"))
+	w, err := Create(zap.NewExample(), p, []byte("somedata"), clockwork.NewFakeClock())
 	if err != nil {
 		t.Fatalf("err = %v, want nil", err)
 	}
@@ -79,17 +80,18 @@ func TestNew(t *testing.T) {
 
 	var wb bytes.Buffer
 	e := newEncoder(&wb, 0, 0)
-	err = e.encode(&walpb.Record{Type: crcType, Crc: 0})
+	err = e.encode(&walpb.Record{Type: crcType, Crc: 0, CreatedAt: w.clock.Now().Unix()})
 	if err != nil {
 		t.Fatalf("err = %v, want nil", err)
 	}
-	err = e.encode(&walpb.Record{Type: metadataType, Data: []byte("somedata")})
+	err = e.encode(&walpb.Record{Type: metadataType, Data: []byte("somedata"), CreatedAt: w.clock.Now().Unix()})
 	if err != nil {
 		t.Fatalf("err = %v, want nil", err)
 	}
 	r := &walpb.Record{
-		Type: snapshotType,
-		Data: pbutil.MustMarshal(&walpb.Snapshot{}),
+		Type:      snapshotType,
+		Data:      pbutil.MustMarshal(&walpb.Snapshot{}),
+		CreatedAt: w.clock.Now().Unix(),
 	}
 	if err = e.encode(r); err != nil {
 		t.Fatalf("err = %v, want nil", err)
diff --git a/server/wal/walpb/record.pb.go b/server/wal/walpb/record.pb.go
index 654d82636..7a59cb6f3 100644
--- a/server/wal/walpb/record.pb.go
+++ b/server/wal/walpb/record.pb.go
@@ -29,6 +29,7 @@ type Record struct {
 	Type                 int64    `protobuf:"varint,1,opt,name=type" json:"type"`
 	Crc                  uint32   `protobuf:"varint,2,opt,name=crc" json:"crc"`
 	Data                 []byte   `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
+	CreatedAt            int64    `protobuf:"varint,4,opt,name=created_at,json=createdAt" json:"created_at"`
 	XXX_NoUnkeyedLiteral struct{} `json:"-"`
 	XXX_unrecognized     []byte   `json:"-"`
 	XXX_sizecache        int32    `json:"-"`
@@ -119,22 +120,23 @@ func init() {
 func init() { proto.RegisterFile("record.proto", fileDescriptor_bf94fd919e302a1d) }
 
 var fileDescriptor_bf94fd919e302a1d = []byte{
-	// 234 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x3c, 0x8e, 0x41, 0x4e, 0xc3, 0x30,
-	0x10, 0x45, 0x63, 0xe2, 0x22, 0x18, 0xca, 0x02, 0xab, 0xaa, 0xa2, 0x2c, 0x4c, 0xd4, 0x55, 0x56,
-	0x29, 0xe2, 0x08, 0x65, 0xcf, 0x22, 0x3d, 0x00, 0x72, 0x1d, 0xa7, 0x20, 0xd1, 0x8c, 0x35, 0xb5,
-	0x04, 0xdc, 0x84, 0x23, 0x65, 0xc9, 0x09, 0x10, 0x84, 0x8b, 0xa0, 0x8c, 0x03, 0x1b, 0xfb, 0xeb,
-	0x7d, 0xf9, 0x7d, 0xc3, 0x9c, 0x9c, 0x45, 0x6a, 0x2a, 0x4f, 0x18, 0x50, 0xcd, 0x5e, 0xcc, 0xb3,
-	0xdf, 0xe5, 0x8b, 0x3d, 0xee, 0x91, 0xc9, 0x7a, 0x4c, 0xb1, 0xcc, 0x97, 0x64, 0xda, 0xb0, 0x1e,
-	0x0f, 0xbf, 0xe3, 0x2b, 0xf2, 0xd5, 0x3d, 0x9c, 0xd6, 0x2c, 0x51, 0x19, 0xc8, 0xf0, 0xe6, 0x5d,
-	0x26, 0x0a, 0x51, 0xa6, 0x1b, 0xd9, 0x7f, 0x5e, 0x27, 0x35, 0x13, 0xb5, 0x84, 0xd4, 0x92, 0xcd,
-	0x4e, 0x0a, 0x51, 0x5e, 0x4e, 0xc5, 0x08, 0x94, 0x02, 0xd9, 0x98, 0x60, 0xb2, 0xb4, 0x10, 0xe5,
-	0xbc, 0xe6, 0xbc, 0x22, 0x38, 0xdb, 0x76, 0xc6, 0x1f, 0x1f, 0x31, 0xa8, 0x1c, 0x66, 0x4f, 0x5d,
-	0xe3, 0x5e, 0x59, 0x29, 0xa7, 0x97, 0x11, 0xf1, 0x9a, 0xa3, 0x03, 0x4b, 0xe5, 0xff, 0x9a, 0xa3,
-	0x83, 0xba, 0x01, 0xb0, 0xd8, 0xb5, 0x0f, 0xc7, 0x60, 0x82, 0x63, 0xf7, 0xc5, 0xed, 0x55, 0x15,
-	0x7f, 0x5e, 0xdd, 0x61, 0xd7, 0x6e, 0xc7, 0xa2, 0x3e, 0xb7, 0x7f, 0x71, 0xb3, 0xe8, 0xbf, 0x75,
-	0xd2, 0x0f, 0x5a, 0x7c, 0x0c, 0x5a, 0x7c, 0x0d, 0x5a, 0xbc, 0xff, 0xe8, 0xe4, 0x37, 0x00, 0x00,
-	0xff, 0xff, 0xc3, 0x36, 0x0c, 0xad, 0x1d, 0x01, 0x00, 0x00,
+	// 253 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x8f, 0x41, 0x4e, 0xc3, 0x30,
+	0x14, 0x44, 0x63, 0xe2, 0x22, 0xfa, 0x29, 0x0b, 0xac, 0xaa, 0xb2, 0xb2, 0x30, 0x51, 0xd9, 0x64,
+	0x95, 0x22, 0x6e, 0x40, 0xb9, 0x41, 0x7a, 0x80, 0xca, 0x75, 0x9c, 0x82, 0x44, 0x62, 0xcb, 0xf9,
+	0x12, 0x70, 0x13, 0x8e, 0x94, 0x25, 0x27, 0x40, 0x10, 0x2e, 0x82, 0xf2, 0x13, 0x10, 0x1b, 0x7b,
+	0xf4, 0xc6, 0x9a, 0x19, 0xc3, 0x22, 0x58, 0xe3, 0x42, 0x99, 0xfb, 0xe0, 0xd0, 0x89, 0xd9, 0xb3,
+	0x7e, 0xf2, 0x87, 0x64, 0x79, 0x74, 0x47, 0x47, 0x64, 0x33, 0xa8, 0xd1, 0x4c, 0x56, 0x41, 0x57,
+	0xb8, 0x19, 0x0e, 0x7f, 0xa0, 0x6b, 0xe4, 0xeb, 0x16, 0x4e, 0x0b, 0x0a, 0x11, 0x12, 0x38, 0xbe,
+	0x7a, 0x2b, 0x59, 0xca, 0xb2, 0x78, 0xcb, 0xbb, 0x8f, 0xab, 0xa8, 0x20, 0x22, 0x56, 0x10, 0x9b,
+	0x60, 0xe4, 0x49, 0xca, 0xb2, 0x8b, 0xc9, 0x18, 0x80, 0x10, 0xc0, 0x4b, 0x8d, 0x5a, 0xc6, 0x29,
+	0xcb, 0x16, 0x05, 0x69, 0x71, 0x0d, 0x60, 0x82, 0xd5, 0x68, 0xcb, 0xbd, 0x46, 0xc9, 0xff, 0x65,
+	0xcd, 0x27, 0x7e, 0x87, 0xeb, 0x00, 0x67, 0xbb, 0x46, 0xfb, 0xf6, 0xc1, 0xa1, 0x48, 0x60, 0xf6,
+	0xd8, 0x94, 0xf6, 0x85, 0x7a, 0xf9, 0xf4, 0x76, 0x44, 0x34, 0xc9, 0x86, 0x9a, 0x9a, 0xf9, 0xdf,
+	0x24, 0x1b, 0x6a, 0x71, 0x03, 0x60, 0x5c, 0x53, 0xed, 0x5b, 0xd4, 0x68, 0x69, 0xc0, 0xf9, 0xed,
+	0x65, 0x3e, 0x7e, 0x2f, 0xbf, 0x77, 0x4d, 0xb5, 0x1b, 0x8c, 0x62, 0x6e, 0x7e, 0xe5, 0x76, 0xd9,
+	0x7d, 0xa9, 0xa8, 0xeb, 0x15, 0x7b, 0xef, 0x15, 0xfb, 0xec, 0x15, 0x7b, 0xfb, 0x56, 0xd1, 0x4f,
+	0x00, 0x00, 0x00, 0xff, 0xff, 0x7a, 0x04, 0x9d, 0xc8, 0x42, 0x01, 0x00, 0x00,
 }
 
 func (m *Record) Marshal() (dAtA []byte, err error) {
@@ -161,6 +163,9 @@ func (m *Record) MarshalToSizedBuffer(dAtA []byte) (int, error) {
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	i = encodeVarintRecord(dAtA, i, uint64(m.CreatedAt))
+	i--
+	dAtA[i] = 0x20
 	if m.Data != nil {
 		i -= len(m.Data)
 		copy(dAtA[i:], m.Data)
@@ -245,6 +250,7 @@ func (m *Record) Size() (n int) {
 		l = len(m.Data)
 		n += 1 + l + sovRecord(uint64(l))
 	}
+	n += 1 + sovRecord(uint64(m.CreatedAt))
 	if m.XXX_unrecognized != nil {
 		n += len(m.XXX_unrecognized)
 	}
@@ -376,6 +382,25 @@ func (m *Record) Unmarshal(dAtA []byte) error {
 				m.Data = []byte{}
 			}
 			iNdEx = postIndex
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
+			}
+			m.CreatedAt = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowRecord
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.CreatedAt |= int64(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
 		default:
 			iNdEx = preIndex
 			skippy, err := skipRecord(dAtA[iNdEx:])
diff --git a/server/wal/walpb/record.proto b/server/wal/walpb/record.proto
index 536fa6c19..ca8b8b41c 100644
--- a/server/wal/walpb/record.proto
+++ b/server/wal/walpb/record.proto
@@ -10,9 +10,10 @@ option (gogoproto.unmarshaler_all) = true;
 option (gogoproto.goproto_getters_all) = false;
 
 message Record {
-	optional int64 type  = 1 [(gogoproto.nullable) = false];
-	optional uint32 crc  = 2 [(gogoproto.nullable) = false];
-	optional bytes data  = 3;
+	optional int64 type        = 1 [(gogoproto.nullable) = false];
+	optional uint32 crc        = 2 [(gogoproto.nullable) = false];
+	optional bytes data        = 3;
+	optional int64 created_at  = 4 [(gogoproto.nullable) = false];
 }
 
 // Keep in sync with raftpb.SnapshotMetadata.
